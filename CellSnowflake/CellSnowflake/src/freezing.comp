#version 450 core

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

//フラグの代わり.....
const uint ISCRYSTAL = 1u;	//ISCRYSTAL
const uint ISEDGECRYSTAL = 2u;	//ISEDGECRYSTAL
const uint ISBOUNDARY = 4u;	//ISBOUNDARY
const uint ISEDGEBOUNDARY = 8u;	//ISEDGEBOUNDARY
const uint MZISODD = 16u;	//セル番号のZ値が奇数である
const uint ISENDOFCELLS = 32u;
//パラメータ
//水晶は準液体相がないので0.0に
const float kappa01 = 0.1, kappa10 = 0.1, kappa11 = 0.1, 
	kappa20 = 0.1, kappa21 = 0.1, kappa30 = 0.1, kappa31 = 0.1;

class Cell
{
	vec4 position;
	vec4 color;
	vec3 neighbourSurfaceDir;
	ivec3 slicedNeighbourNums;
	vec3 vertexNormal;
	uint flags;
	float diffusionMass;
	float boundaryMass;
	int horizontalNeighbourNum;
	int verticalNeighbourNum;
	int neighbourNum;
};

layout(std430, binding = 0) buffer Cells
{
	Cell cell[];
};

layout(std430, binding = 1) buffer tmpCells
{
	Cell tmpCell[];
};

//flagIDは2進数の値
//flagsのビットのfragID番目（0から）が1ならtrue
bool isFlag(uint i, uint flagID) {
	return ((cell[i].flags & flagID) != 0);
}

float random (vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);
}

void main(){
	
	const uint i = gl_WorkGroupID.y * gl_NumWorkGroups.x * gl_NumWorkGroups.z +
		gl_WorkGroupID.z * gl_NumWorkGroups.x +
		gl_WorkGroupID.x;

	if(isFlag(i, ISEDGEBOUNDARY) && !isFlag(i, ISENDOFCELLS)){
		const int h = min(3, cell[i].horizontalNeighbourNum);
		const int v = min(1, cell[i].verticalNeighbourNum);

		float kappa = 0.0;

		/*
		//旧
		if(h == 0 && v == 1){
			kappa = kappa01;
		}else if(h == 1 && v == 0){
			kappa = kappa10;
		}else if(h == 1 && v == 1){
			kappa = kappa11;
		}else if(h == 2 && v == 0){
			kappa = kappa20;
		}else if(h == 2 && v == 1){
			kappa = kappa21;
		}else if(h == 3 && v == 0){
			kappa = kappa30;
		}else if(h == 3 && v == 1){
			kappa = kappa31;
		}else{
			kappa = 999;
		}
		*/

		/*
		//適当にランダム性を入れてみる
		float ran = random(vec2(i, i)) * 0.8;
		//tmpCell[i].color = vec4(vec3(ran), 1.0);
		kappa += ran;
		*/

		/*
		//てすと周囲のセル状況に応じて凍結具合を変えてみる
		ivec3 tmpSliNeiNums = cell[i].slicedNeighbourNums;
		ivec3 fixedSliNeiNums
			 = tmpSliNeiNums.x > tmpSliNeiNums.z ? tmpSliNeiNums.xyz : tmpSliNeiNums.zyx;
		if(fixedSliNeiNums.x == 0){
			kappa = 1.0;
		}
		else if(fixedSliNeiNums.z > 3 || fixedSliNeiNums.y > 3){
			kappa = 0.0;																//埋め
		}else if(fixedSliNeiNums.z > 0){
			kappa = fixedSliNeiNums.y == 1 || fixedSliNeiNums.z == 1 ? 0.8 : 0.1;	//垂角薄赤:垂面薄緑
		}else{
			if(fixedSliNeiNums.y == 0){
				kappa = fixedSliNeiNums.x == 1 ? 0.1 : 0.4;							//頂点赤:平面緑
			}else{
				if(fixedSliNeiNums.x > 1 && fixedSliNeiNums.y > 1){
					kappa = fixedSliNeiNums.x > 4 ? 0.1 : 0.1;						//角面紫:斜面水色
				}else{
					kappa = fixedSliNeiNums.x > 3 ? 0.3 : 0.0;						//斜角黄:角青
				}
			}

		}
		*/

		float tmpBoundaryMass = cell[i].boundaryMass + (1 - kappa) * cell[i].diffusionMass;
		float tmpDiffusionMass = kappa * cell[i].diffusionMass;

		tmpCell[i].diffusionMass = tmpDiffusionMass;
		tmpCell[i].boundaryMass = tmpBoundaryMass;



		//tmpCell[i].color = vec4(0.0, cell[i].boundaryMass, cell[i].boundaryMass, 1.0);

	}
}
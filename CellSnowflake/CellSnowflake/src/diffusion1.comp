#version 450 core

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

//フラグの代わり.....
const uint ISCRYSTAL = 1;	//ISCRYSTAL
const uint ISEDGECRYSTAL = 2;	//ISEDGECRYSTAL
const uint ISBOUNDARY = 4;	//ISBOUNDARY
const uint ISEDGEBOUNDARY = 8;	//ISEDGEBOUNDARY
const uint MZISODD = 16;	//セル番号のZ値が奇数である
const uint ISENDOFCELLS = 32;

class Cell
{
	vec4 position;
	vec4 color;
	vec3 neighbourSurfaceDir;
	ivec3 slicedNeighbourNums;
	vec3 vertexNormal;
	uint flags;
	float diffusionMass;
	float boundaryMass;
	int horizontalNeighbourNum;
	int verticalNeighbourNum;
	int neighbourNum;
};

layout(std430, binding = 0) buffer Cells
{
	Cell cell[];
};

layout(std430, binding = 1) buffer tmpCells
{
	Cell tmpCell[];
};

//flagIDは2進数の値
//flagsのビットのfragID番目（0から）が1ならtrue
bool isFlag(uint i, uint flagID) {
	return ((cell[i].flags & flagID) != 0);
}
void setFlagTrue(uint i, uint flagID) {
	tmpCell[i].flags |= flagID;
}
void setFlagFalse(uint i, uint flagID) {
	tmpCell[i].flags &= ~flagID;
}

//２次元座標から乱数
float random (vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
}

void main(){
	
	const uint i = gl_WorkGroupID.y * gl_NumWorkGroups.x * gl_NumWorkGroups.z +
		gl_WorkGroupID.z * gl_NumWorkGroups.x +
		gl_WorkGroupID.x;
	const uint gridNumX = gl_NumWorkGroups.x, gridNumZ = gl_NumWorkGroups.z;

	int zOddNum = int(isFlag(i, MZISODD)) * 2 - 1;	//名前思いつかん
	const uint[6] aroundCellIDs = uint[](i + 1, i - 1, i + gridNumX, i - gridNumX,
		i + gridNumX + zOddNum, i - gridNumX + zOddNum);
	
	//diffusion_1
	if(!isFlag(i, ISCRYSTAL) && !isFlag(i, ISENDOFCELLS)){		//気体であり端っこでない
		float tmpDiffusionMass = 0.0;
		/*
		//旧拡散
		//水平
		float horiDiffMass = 0.0;
		horiDiffMass = cell[i].diffusionMass +
			cell[aroundCellIDs[0]].diffusionMass + 
			cell[aroundCellIDs[1]].diffusionMass + 
			cell[aroundCellIDs[2]].diffusionMass + 
			cell[aroundCellIDs[3]].diffusionMass + 
			cell[aroundCellIDs[4]].diffusionMass + 
			cell[aroundCellIDs[5]].diffusionMass;
		horiDiffMass /= 7.0;
		//垂直
		float verDiffMass = 0.0;
		verDiffMass += cell[i + gridNumX * gridNumZ].diffusionMass +
			cell[i - gridNumX * gridNumZ].diffusionMass;	//どうも足すだけ
		
		//拡散質量計算　水平4/7 垂直 3/7 (↓の式では垂直の２で割るのを含めている)
		//なぜか垂直の割合を増やすと水平方向の成長が進む
		tmpDiffusionMass = horiDiffMass * 4.0 / 7.0 + verDiffMass * 3.0 / 14.0;
		
		//垂直水平関係なく拡散
		//tmpDiffusionMass = (horiDiffMass + verDiffMass) / 9.0;
		*/
		
		
		//周囲２０マスで拡散　簡単のため垂直:水平 = 1:1とする
		uint id;
		for(int aro_i = 0; aro_i < aroundCellIDs.length; ++aro_i){
			id = aroundCellIDs[aro_i];
			tmpDiffusionMass += cell[id].diffusionMass / (0.4 + 0.3 * sqrt(2.0));
		}
		//上周囲
		for(int aro_i = 0; aro_i < aroundCellIDs.length; ++aro_i){
			id = aroundCellIDs[aro_i] + gridNumX * gridNumZ;
			tmpDiffusionMass += cell[id].diffusionMass * sqrt(2.0) * 0.5 / (0.4 + 0.3 * sqrt(2.0));
				
		}
		//下周囲
		for(int aro_i = 0; aro_i < aroundCellIDs.length; ++aro_i){
			id = aroundCellIDs[aro_i] - gridNumX * gridNumZ;
			tmpDiffusionMass += cell[id].diffusionMass * sqrt(2.0) * 0.5 / (0.4 + 0.3 * sqrt(2.0));
				
		}
		//真上真下
		tmpDiffusionMass += cell[i+gridNumX*gridNumZ].diffusionMass / (0.4 + 0.3 * sqrt(2.0));
		tmpDiffusionMass += cell[i-gridNumX*gridNumZ].diffusionMass / (0.4 + 0.3 * sqrt(2.0));
		
		tmpDiffusionMass *= 0.05;	//20で割る
		
		//ノイズ
		//元論文の実装。うまくいかん
		//tmpDiffusionMass *= 1.0 + 0.1 * (step(0.515, (random(vec2(i, i)) )) * 2 - 1);
		
		//tmpDiffusionMass *= 1.0 + 0.2 * ((int(i) % 2) * 2 - 1);

		//これもなんか惜しい感じ
		//tmpDiffusionMass *= (1.0 + (random(vec2(i+100, i)) * 2 - 1) * 0.2);

		tmpCell[i].diffusionMass = tmpDiffusionMass;
	}
}